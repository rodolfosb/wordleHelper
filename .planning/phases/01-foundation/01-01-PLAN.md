---
phase: 01-foundation
plan: 01
type: execute
depends_on: []
files_modified: [package.json, tsconfig.json, vite.config.ts, index.html, src/main.ts, src/data/words.ts, src/types/index.ts]
---

<objective>
Set up the Wordle Helper project with TypeScript tooling and a comprehensive word list.

Purpose: Establish the foundation that all subsequent phases depend on - a working dev environment and the core data (word list) the app will use.
Output: Runnable Vite project with TypeScript, 5-letter word list loaded and accessible, core types defined.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

**Key context:**
- Web application for helping solve Wordle puzzles
- No technology constraints specified - free to use best-fit tools
- Target: responsive web UI (not mobile app)
- Wordle uses 5-letter words, 6 guesses, green/yellow/gray feedback
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold Vite + TypeScript project</name>
  <files>package.json, tsconfig.json, vite.config.ts, index.html, src/main.ts</files>
  <action>
Initialize a new Vite project with TypeScript template. Use `npm create vite@latest . -- --template vanilla-ts` (in current directory since it's empty except .planning and .git).

After scaffolding:
- Ensure tsconfig.json has strict mode enabled
- Update index.html title to "Wordle Helper"
- Verify dev server runs with `npm run dev`

Avoid: React or other frameworks - vanilla TypeScript is sufficient for this app's complexity. Keep it simple.
  </action>
  <verify>npm run dev starts without errors; visiting localhost shows default Vite page</verify>
  <done>Vite dev server runs, TypeScript compiles, project structure exists</done>
</task>

<task type="auto">
  <name>Task 2: Create word list data module</name>
  <files>src/data/words.ts</files>
  <action>
Create `src/data/words.ts` containing a comprehensive 5-letter word list for Wordle.

Source the word list: Use a well-known Wordle word list. The two canonical lists are:
1. Solutions list (~2,300 words) - actual Wordle answers
2. Valid guesses list (~10,000+ words) - all accepted guesses

For this app, use a combined/curated list of common 5-letter English words. A reasonable approach is to embed the words directly as a string array (the file size is acceptable at ~50-100KB).

Structure:
```typescript
// src/data/words.ts
export const WORD_LIST: string[] = [
  // alphabetically sorted 5-letter words
  "about",
  "above",
  // ... etc
];

export const WORD_SET: Set<string> = new Set(WORD_LIST);
```

Include at minimum the ~2,300 official Wordle solution words. Optionally include additional common 5-letter words. All words should be lowercase.

You can find word lists from public sources (e.g., GitHub repositories with Wordle word lists, or generate from standard word frequency lists). Ensure words are actual English words.
  </action>
  <verify>Import works: `import { WORD_LIST } from './data/words'` compiles; WORD_LIST.length > 2000</verify>
  <done>WORD_LIST exported with 2000+ 5-letter words, WORD_SET for O(1) lookup, TypeScript compiles</done>
</task>

<task type="auto">
  <name>Task 3: Define core types</name>
  <files>src/types/index.ts, src/main.ts</files>
  <action>
Create `src/types/index.ts` with TypeScript types for the Wordle domain:

```typescript
// Letter feedback from Wordle
export type LetterStatus = 'green' | 'yellow' | 'gray';

// A single letter with its position and feedback
export interface LetterFeedback {
  letter: string;      // lowercase a-z
  position: number;    // 0-4
  status: LetterStatus;
}

// A complete guess (5 letters with feedback)
export type GuessFeedback = [LetterFeedback, LetterFeedback, LetterFeedback, LetterFeedback, LetterFeedback];

// Accumulated constraints from all guesses
export interface Constraints {
  // Letters known to be in exact positions (green)
  exactPositions: Map<number, string>;  // position -> letter

  // Letters known to be in word but not in these positions (yellow)
  requiredLetters: Map<string, Set<number>>;  // letter -> excluded positions

  // Letters known to not be in word at all (gray)
  excludedLetters: Set<string>;
}
```

Update `src/main.ts` to import and use these types (just a simple verification that types work):

```typescript
import { WORD_LIST } from './data/words';
import type { Constraints } from './types';

console.log(`Wordle Helper loaded with ${WORD_LIST.length} words`);

// Type check: empty constraints
const initialConstraints: Constraints = {
  exactPositions: new Map(),
  requiredLetters: new Map(),
  excludedLetters: new Set(),
};

console.log('Initial constraints:', initialConstraints);
```
  </action>
  <verify>npm run build succeeds with no TypeScript errors; npm run dev shows console output with word count</verify>
  <done>Types exported, main.ts compiles and runs with type-checked code, console shows word count</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run dev` starts dev server without errors
- [ ] `npm run build` compiles TypeScript with no errors
- [ ] Browser console shows "Wordle Helper loaded with X words" where X > 2000
- [ ] All files exist: package.json, src/data/words.ts, src/types/index.ts, src/main.ts
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- Word list contains 2000+ valid 5-letter words
- Core types defined for letter feedback and constraints
- Dev server runnable
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`:

# Phase 1 Plan 01: Foundation Summary

**[One-liner describing what was built]**

## Accomplishments

- [Key outcomes]

## Files Created/Modified

- `package.json` - Vite + TypeScript dependencies
- `src/data/words.ts` - Word list (N words)
- `src/types/index.ts` - Core domain types
- `src/main.ts` - Entry point with type verification

## Decisions Made

[Any decisions made during implementation]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Ready for Phase 2: Core Logic (word filtering engine)
</output>

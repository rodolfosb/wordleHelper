---
phase: 03-ranking-system
plan: 01
type: execute
depends_on: []
files_modified: [src/logic/frequency.ts, src/main.ts]
---

<objective>
Implement letter frequency analysis and frequency-based word scoring.

Purpose: Provide a fast, simple ranking method that surfaces words with common letters - useful for early guesses when no feedback exists yet.
Output: Functions to calculate letter frequencies and score/rank words by frequency.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-logic/02-01-SUMMARY.md

**Tech available:** Vite, TypeScript
**Established patterns:**
- Types in src/types/index.ts
- Logic modules in src/logic/ directory
- Data exports from src/data/words.ts (WORD_LIST, WORD_SET)

**Key files:**
@src/data/words.ts
@src/logic/filter.ts
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create letter frequency calculator</name>
  <files>src/logic/frequency.ts</files>
  <action>
Create frequency.ts in src/logic/ with:

1. `calculateLetterFrequencies(words: string[]): Map<string, number>` - Analyze word list and count total occurrences of each letter (a-z). Return map of letter -> count.

2. `calculatePositionalFrequencies(words: string[]): Map<string, number>[]` - For each position (0-4), count letter occurrences at that position. Returns array of 5 Maps.

Both functions should work with any word list (the filtered list, not just WORD_LIST).

Export both functions.
  </action>
  <verify>Import in main.ts, call calculateLetterFrequencies(WORD_LIST), log top 5 most frequent letters. Expected: e, a, r, o, t or similar common letters.</verify>
  <done>Functions exported, frequency map correctly counts letters, console shows sensible frequency ranking.</done>
</task>

<task type="auto">
  <name>Task 2: Create frequency-based word scorer</name>
  <files>src/logic/frequency.ts</files>
  <action>
Add to frequency.ts:

1. `scoreWordByFrequency(word: string, frequencies: Map<string, number>): number` - Sum the frequency scores of each UNIQUE letter in the word. Using unique letters rewards diversity (e.g., "crane" > "geese" because "crane" has 5 unique letters vs "geese" has 3).

2. `rankWordsByFrequency(words: string[], baseWordList: string[]): string[]` - Calculate frequencies from baseWordList, score each word in words[], return sorted descending by score.

Note: baseWordList is typically WORD_LIST (for overall frequency) but could be the filtered list for context-aware scoring.

Export both functions.
  </action>
  <verify>Call rankWordsByFrequency(WORD_LIST.slice(0, 100), WORD_LIST), log top 10 words. Expect words with common, diverse letters like "crane", "slate", "crate", "trace" near the top.</verify>
  <done>Scoring and ranking functions work, results prioritize words with common unique letters.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] Letter frequencies show expected distribution (e, a, r most common)
- [ ] Word ranking prioritizes diverse common-letter words
- [ ] All functions properly typed and exported
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- Frequency analysis produces sensible letter rankings
- Word scorer rewards common, diverse letter usage
</success_criteria>

<output>
After completion, create `.planning/phases/03-ranking-system/03-01-SUMMARY.md`
</output>
